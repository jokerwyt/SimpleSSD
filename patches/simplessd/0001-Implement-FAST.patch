From 896d255faf2a4181f49f02032136038197072b1a Mon Sep 17 00:00:00 2001
From: jokerwyt <914554688@qq.com>
Date: Thu, 18 Jan 2024 00:12:48 +0800
Subject: [PATCH 1/2] Implement FAST

---
 CMakeLists.txt           |   3 +-
 config/fast_fill_0.5.cfg | 494 +++++++++++++++++++++++
 config/fast_fill_0.cfg   | 494 +++++++++++++++++++++++
 config/page_fill_0.5.cfg | 494 +++++++++++++++++++++++
 config/page_fill_0.cfg   | 494 +++++++++++++++++++++++
 config/sample.cfg        |  21 +-
 ftl/common/block.cc      |  32 +-
 ftl/common/block.hh      |  10 +
 ftl/config.hh            |   1 +
 ftl/fast_mapping.cc      | 821 +++++++++++++++++++++++++++++++++++++++
 ftl/fast_mapping.hh      | 173 +++++++++
 ftl/ftl.cc               |   4 +
 hil/nvme/controller.cc   |   1 +
 sim/trace.hh             |   1 +
 14 files changed, 3029 insertions(+), 14 deletions(-)
 create mode 100644 config/fast_fill_0.5.cfg
 create mode 100644 config/fast_fill_0.cfg
 create mode 100644 config/page_fill_0.5.cfg
 create mode 100644 config/page_fill_0.cfg
 create mode 100644 ftl/fast_mapping.cc
 create mode 100644 ftl/fast_mapping.hh

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 38bb5a4..aedc52b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -78,7 +78,7 @@ else ()
   endif ()
 endif ()
 
-set(CMAKE_CXX_STANDARD 11)
+set(CMAKE_CXX_STANDARD 17)
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
 
 # Specify source files
@@ -98,6 +98,7 @@ set(SRC_FTL
   ftl/config.cc
   ftl/ftl.cc
   ftl/page_mapping.cc
+  ftl/fast_mapping.cc
 )
 set(SRC_HIL_NVME
   hil/nvme/abstract_subsystem.cc
diff --git a/config/fast_fill_0.5.cfg b/config/fast_fill_0.5.cfg
new file mode 100644
index 0000000..1226b3f
--- /dev/null
+++ b/config/fast_fill_0.5.cfg
@@ -0,0 +1,494 @@
+#
+# Copyright (C) 2017 CAMELab
+#
+# This file is part of SimpleSSD.
+#
+# SimpleSSD is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# SimpleSSD is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with SimpleSSD.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+#
+# Sample SimpleSSD Configuration File
+#
+# Section:
+# cpu:  SSD Controller CPU configuration
+# nvme: Non-Volatile Memory Express configuration
+# ufs:  Universal Flash Storage configuration
+# sata: Serial ATA configuration
+# pal:  Parallelism Abstraction Layer configuration
+# ftl:  Flash Translation Layer configuration
+# icl:  Internal Cache Layer configuration
+# dram: DRAM configuration
+#
+
+# SSD Controller CPU configuration
+[cpu]
+## Set clock speed in Hz
+ClockSpeed = 400000000
+
+## Set dedicated core count
+HILCoreCount = 1
+ICLCoreCount = 1
+FTLCoreCount = 1
+
+# NVMe interface Configuration
+[nvme]
+
+## PCI Express Interface
+# Set PCIe generation and lane count
+# Possible values:
+#  0: PCI Express 1.x (2.5GT/s/lane)
+#  1: PCI Express 2.x (5GT/s/lane)
+#  2: PCI Express 3.x (8GT/s/lane)
+PCIEGeneration = 2
+PCIELane = 4
+
+## PCI Express Endpoint <-> NVMe Controller
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 2
+AXIClock = 250000000  # 128bit @ 250MHz -> 4GB/s
+
+## Hardware FIFO Transfer unit
+# Smaller value introduce smaller latency
+FIFOTransferUnit = 2048
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## Set maximum number of I/O queue that controller supports
+# You should check BAR0 size to fit all doorbell
+# Doorbell stride is always 0 (4bytes align)
+MaxIOCQueue = 16
+MaxIOSQueue = 16
+
+## Set parameters of Weighted Round robin
+# Set how many commands should be inserted to internal FIFO
+# before switch to next low priority
+WRRHigh = 2     # Medium-priority command will inserted after two high-priority commands inserted
+WRRMedium = 2   # Low-priority command will inserted after two medium-priority command inserted
+
+## Default Namespace
+# Specify number of namespaces to create
+# Each namespace has same capacity
+DefaultNamespace = 1
+
+## LBA Size
+# Set logical block size of default namespace
+# If DefaultNamespace is false, this value will ignored
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk size check
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+
+## List of disk image path for each namespace
+# e.g. Setting disk image for namespace 2 -> DiskImageFile2 = <image path>
+DiskImageFile1 = nvme.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Universal Flash Storage Configuration
+[ufs]
+
+## AMBA System Bus <-> UFS Host Controller
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 1
+AXIClock = 250000000  # 64bit @ 250MHz -> 2GB/s
+
+## UFS Host Controller <-> UFS Device
+# Set MIPI M-PHY mode and lane count
+# Possible values:
+#  0: HS-G1
+#  1: HS-G2
+#  2: HS-G3
+#  3: HS-G4
+MPHYMode = 2
+MPHYLane = 2
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## LBA Size
+# Set logical block size of default namespace
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk Image Filename
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+DiskImageFile = ufs.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Serial ATA Configuration
+[sata]
+
+## PCI Express Interface
+# Set PCIe generation and lane count
+# Possible values:
+#  0: PCI Express 1.x (2.5GT/s/lane)
+#  1: PCI Express 2.x (5GT/s/lane)
+#  2: PCI Express 3.x (8GT/s/lane)
+PCIEGeneration = 2
+PCIELane = 4
+
+## PCI Express Endpoint <-> NSATA AHCI HBA
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 2
+AXIClock = 250000000  # 128bit @ 250MHz -> 4GB/s
+
+## SATA AHCI HBA <-> SATA Device
+# Set SATA generation
+# Possible values:
+#  0: SATA 1.0 (1.5Gbps)
+#  1: SATA 2.0 (3Gbps)
+#  2: SATA 3.0 (6Gbps)
+SATAMode = 2
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## LBA Size
+# Set logical block size of default namespace
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk Image Filename
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+DiskImageFile = sata.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Parallelism Abstraction Layer Configuration
+[pal]
+
+## Set SSD structure
+#  Channel: # of channels in SSD
+#  Package: # of packages in one channel
+Channel = 8
+Package = 4
+
+## Set NAND package structure
+#  Die:      # of die in one package
+#  Plane:    # of plane in one die
+#  Block:    # of block in one plane
+#  Page:     # of page in one block
+#  PageSize: Size of one page in byte
+Die = 4
+Plane = 1
+Block = 512
+Page = 512
+PageSize = 4096
+
+## Multi-plane operation
+# 1 for enable multi-plane operation
+EnableMultiPlaneOperation = 1
+
+## Set type of NAND flash
+# Possible values:
+#  0: Single Level Cell
+#  1: Multi Level Cell
+#  2: Triple Level Cell
+# Please check NAND timing has valid values
+#  SLC: LSB timing should valid
+#  MLC: LSB and MSB timing should valid
+#  TLC: LSB, CSB and MSB timing should valid
+NANDType = 1
+
+## Set NAND timing
+LSBRead = 40000000
+LSBWrite = 500000000
+CSBRead = 0
+CSBWrite = 0
+MSBRead = 65000000
+MSBWrite = 1300000000
+Erase = 3500000000
+
+## Set speed and width of DMA in channel in MT/s
+# Width should be 8 or 16
+# Typical values from ONFi:
+#         ONFi   1.x     2.x   3.x~4.x    4.x
+#  Timing Mode   SDR   NV-DDR  NV-DDR2  NV-DDR3
+#      0         10      40      67       67
+#      1         20      67      80       80
+#      2         29     100     133      133
+#      3         33     133     167      167
+#      4         40     167     200      200
+#      5         50     200     267      267
+#      6          -       -     333      333
+#      7          -       -     400      400
+#      8          -       -     533      533
+#      9          -       -       -      667
+#     10          -       -       -      800
+DMASpeed = 400
+DMAWidth = 8
+
+## Set superblock/page size
+# Superblock/page size will multiplied by each values
+# Leave empty will disable superblock feature
+# Possible values:
+#  C: # Channel
+#  W: # Package/Way
+#  D: # Die
+#  P: # Plane (If multi-plane mode is enabled, P will always applied)
+SuperblockSize = 
+
+## Set page allocation order
+# This order will used when disassembling logical address to physical address
+# Possible values:
+#  C: Channel
+#  W: Package/Way
+#  D: Die
+#  P: Plane
+PageAllocation = CWDP
+
+# Flash Translation Layer Configuration
+[ftl]
+
+## Set mapping method
+# Possible values:
+#  0: Page level mapping
+#  1: FAST mapping
+MappingMode = 1
+
+## Set FTL over-provisioning ratio
+OverProvisioningRatio = 0.25
+
+## Set FTL erase threshold to mark as bad block
+EraseThreshold = 100000
+
+## Filling options
+# Filling Mode
+# Possible values:
+#  0: Sequential filling + Sequential invalidation
+#  1: Sequential filling + Random invalidation
+#  2: Random filling + Random invalidation
+FillingMode = 0
+# FillRatio
+# Fill (warm-up) pages before simulation
+# Set # pages to write (Ratio to total logical pages)
+# 0.0 <= val <= 1.0
+FillRatio = 0.5
+# InvalidPageRatio
+# Create invalid pages by overwrite filled pages
+# Set # pages to write (Ratio to total logical pages)
+# 0.0 <= val <= 1.0
+InvalidPageRatio = 0.0
+
+## Set victim selection algorithm
+# Possible values:
+#  0: Greedy: Choose least utilized block to clean
+#  1: Cost-Benefit: Choose a block that lowest (Utilization / ((1 - Utilization) * Age))
+#  2: Random: Choose random block
+#  3: D-CHOICE: Choose least utilized block in randomly sampled blocks
+EvictPolicy = 0
+
+## DChoice parameter
+# When sampling blocks, total blocks to erase * DChoiceParam will be selected
+DChoiceParam = 3
+
+## Set garbage collection threshold (ratio of free blocks left)
+GCThreshold = 0.05
+
+## Garbage collection mode
+# Possible values:
+#  0: Reclaim n blocks
+#  1: Reclaim blocks until threshold
+GCMode = 0
+
+## Specify n (Only in GCMode = 0)
+# n > 0
+GCReclaimBlocks = 1
+
+## Specify threshold (Only in GCMode = 1)
+# t > GCThreshold
+GCReclaimThreshold = 0.1
+
+## Random I/O tweak
+# Enable random I/O tweak when using superpage based mapping
+EnableRandomIOTweak = 0
+
+# Internal Cache Layer Configuration
+[icl]
+
+## Set Cache size
+# Cacheline size = physical page size * (multi-plane mode ? plane count : 1)
+# Directed-map cache: Set way as 1
+# Fully-associative cache: Set way value as 0
+CacheSize = 536870912   # 512MiB
+CacheWaySize = 8
+
+## Set read caching (1 for enable)
+EnableReadCache = 0
+
+## Set read prefetching (1 for enable)
+EnableReadPrefetch = 0
+
+## Set prefetch granularity
+# Possible values:
+#  0: One super page
+#  1: One page from all NAND flashes
+ReadPrefetchMode = 0
+
+## Set # of I/O to determine sequential access
+# Value < 1 is invalid
+# 1 means if 2 contiguous I/O is sequential, prefetch will be enabled
+ReadPrefetchCount = 3
+
+## Set size of sequential I/O to determine as sequential access
+# At least (Super page size * ratio) should be accessed as sequential
+# 0 < ratio
+ReadPrefetchRatio = 0.25
+
+## Set write caching (1 for enable)
+EnableWriteCache = 0
+
+## Set cache evict policy
+# Possible values:
+#  0: RANDOM: Evict entry in random fashion
+#  1: FIFO: Evict most oldest entry in selected set
+#  2: LRU: Evict least recently used entry in selected set
+EvictPolicy = 2
+
+## Set cache evict granularity
+# Possible values:
+#  0: One super page
+#  1: One page from all NAND flashes
+EvictMode = 1
+
+## Set cache metadata latency
+# Byte / ps
+CacheLatency = 10
+
+# DRAM configuration
+[dram]
+
+## Select DRAM model to use
+# Possible values:
+#  0: Simple DRAM model based on atomic dram controller of gem5
+Model = 0
+
+## DRAM structure parameters
+Channel = 1
+Rank = 1
+Bank = 8
+Chip = 1
+BusWidth = 32
+BurstLength = 8
+ChipSize = 1073741824
+PageSize = 4096
+
+## DRAM timing parameters (Unit: ps)
+# tCK = 1250
+# tRCD = 13750
+# tCL = 13750
+# tRP = 13750
+# tRAS = 35000
+# tWR = 15000
+# tRTP = 7500
+# tBURST
+# tCCD_L =
+# tRFC = 160000  # 160ns ~ 70200ns
+# tREFI = 7800000
+# tWTR = 7500
+# tRTW =
+# tCS =
+# tRRD = 6000
+# tRRD_L =
+# tXAW =
+# tXP = 6000
+# tXPDLL = 24000
+# tXS = 170000  # tRFC + 10ns
+# tXSDLL = 640000
+
+## DRAM power parameters (Unit: mA or V)
+# IDD0_0 = 40
+# IDD0_1 = 0
+# IDD2P0_0 = 12
+# IDD2P0_1 = 0
+# IDD2P1_0 = 14
+# IDD2P1_1 = 0
+# IDD2N_0 = 21
+# IDD2N_1 = 0
+# IDD3P0_0 = 21
+# IDD3P0_1 = 0
+# IDD3P1_0 = 21
+# IDD3P1_1 = 0
+# IDD3N_0 = 34
+# IDD3N_1 = 0
+# IDD4R_0 = 100
+# IDD4R_1 = 0
+# IDD4W_0 = 105
+# IDD4W_1 = 0
+# IDD5_0 = 182
+# IDD5_1 = 0
+# IDD6_0 = 12
+# IDD6_1 = 0
+# VDD_0 = 1.35
+# VDD_1 = 0
diff --git a/config/fast_fill_0.cfg b/config/fast_fill_0.cfg
new file mode 100644
index 0000000..1224ecd
--- /dev/null
+++ b/config/fast_fill_0.cfg
@@ -0,0 +1,494 @@
+#
+# Copyright (C) 2017 CAMELab
+#
+# This file is part of SimpleSSD.
+#
+# SimpleSSD is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# SimpleSSD is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with SimpleSSD.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+#
+# Sample SimpleSSD Configuration File
+#
+# Section:
+# cpu:  SSD Controller CPU configuration
+# nvme: Non-Volatile Memory Express configuration
+# ufs:  Universal Flash Storage configuration
+# sata: Serial ATA configuration
+# pal:  Parallelism Abstraction Layer configuration
+# ftl:  Flash Translation Layer configuration
+# icl:  Internal Cache Layer configuration
+# dram: DRAM configuration
+#
+
+# SSD Controller CPU configuration
+[cpu]
+## Set clock speed in Hz
+ClockSpeed = 400000000
+
+## Set dedicated core count
+HILCoreCount = 1
+ICLCoreCount = 1
+FTLCoreCount = 1
+
+# NVMe interface Configuration
+[nvme]
+
+## PCI Express Interface
+# Set PCIe generation and lane count
+# Possible values:
+#  0: PCI Express 1.x (2.5GT/s/lane)
+#  1: PCI Express 2.x (5GT/s/lane)
+#  2: PCI Express 3.x (8GT/s/lane)
+PCIEGeneration = 2
+PCIELane = 4
+
+## PCI Express Endpoint <-> NVMe Controller
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 2
+AXIClock = 250000000  # 128bit @ 250MHz -> 4GB/s
+
+## Hardware FIFO Transfer unit
+# Smaller value introduce smaller latency
+FIFOTransferUnit = 2048
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## Set maximum number of I/O queue that controller supports
+# You should check BAR0 size to fit all doorbell
+# Doorbell stride is always 0 (4bytes align)
+MaxIOCQueue = 16
+MaxIOSQueue = 16
+
+## Set parameters of Weighted Round robin
+# Set how many commands should be inserted to internal FIFO
+# before switch to next low priority
+WRRHigh = 2     # Medium-priority command will inserted after two high-priority commands inserted
+WRRMedium = 2   # Low-priority command will inserted after two medium-priority command inserted
+
+## Default Namespace
+# Specify number of namespaces to create
+# Each namespace has same capacity
+DefaultNamespace = 1
+
+## LBA Size
+# Set logical block size of default namespace
+# If DefaultNamespace is false, this value will ignored
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk size check
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+
+## List of disk image path for each namespace
+# e.g. Setting disk image for namespace 2 -> DiskImageFile2 = <image path>
+DiskImageFile1 = nvme.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Universal Flash Storage Configuration
+[ufs]
+
+## AMBA System Bus <-> UFS Host Controller
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 1
+AXIClock = 250000000  # 64bit @ 250MHz -> 2GB/s
+
+## UFS Host Controller <-> UFS Device
+# Set MIPI M-PHY mode and lane count
+# Possible values:
+#  0: HS-G1
+#  1: HS-G2
+#  2: HS-G3
+#  3: HS-G4
+MPHYMode = 2
+MPHYLane = 2
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## LBA Size
+# Set logical block size of default namespace
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk Image Filename
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+DiskImageFile = ufs.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Serial ATA Configuration
+[sata]
+
+## PCI Express Interface
+# Set PCIe generation and lane count
+# Possible values:
+#  0: PCI Express 1.x (2.5GT/s/lane)
+#  1: PCI Express 2.x (5GT/s/lane)
+#  2: PCI Express 3.x (8GT/s/lane)
+PCIEGeneration = 2
+PCIELane = 4
+
+## PCI Express Endpoint <-> NSATA AHCI HBA
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 2
+AXIClock = 250000000  # 128bit @ 250MHz -> 4GB/s
+
+## SATA AHCI HBA <-> SATA Device
+# Set SATA generation
+# Possible values:
+#  0: SATA 1.0 (1.5Gbps)
+#  1: SATA 2.0 (3Gbps)
+#  2: SATA 3.0 (6Gbps)
+SATAMode = 2
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## LBA Size
+# Set logical block size of default namespace
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk Image Filename
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+DiskImageFile = sata.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Parallelism Abstraction Layer Configuration
+[pal]
+
+## Set SSD structure
+#  Channel: # of channels in SSD
+#  Package: # of packages in one channel
+Channel = 8
+Package = 4
+
+## Set NAND package structure
+#  Die:      # of die in one package
+#  Plane:    # of plane in one die
+#  Block:    # of block in one plane
+#  Page:     # of page in one block
+#  PageSize: Size of one page in byte
+Die = 4
+Plane = 1
+Block = 512
+Page = 512
+PageSize = 4096
+
+## Multi-plane operation
+# 1 for enable multi-plane operation
+EnableMultiPlaneOperation = 1
+
+## Set type of NAND flash
+# Possible values:
+#  0: Single Level Cell
+#  1: Multi Level Cell
+#  2: Triple Level Cell
+# Please check NAND timing has valid values
+#  SLC: LSB timing should valid
+#  MLC: LSB and MSB timing should valid
+#  TLC: LSB, CSB and MSB timing should valid
+NANDType = 1
+
+## Set NAND timing
+LSBRead = 40000000
+LSBWrite = 500000000
+CSBRead = 0
+CSBWrite = 0
+MSBRead = 65000000
+MSBWrite = 1300000000
+Erase = 3500000000
+
+## Set speed and width of DMA in channel in MT/s
+# Width should be 8 or 16
+# Typical values from ONFi:
+#         ONFi   1.x     2.x   3.x~4.x    4.x
+#  Timing Mode   SDR   NV-DDR  NV-DDR2  NV-DDR3
+#      0         10      40      67       67
+#      1         20      67      80       80
+#      2         29     100     133      133
+#      3         33     133     167      167
+#      4         40     167     200      200
+#      5         50     200     267      267
+#      6          -       -     333      333
+#      7          -       -     400      400
+#      8          -       -     533      533
+#      9          -       -       -      667
+#     10          -       -       -      800
+DMASpeed = 400
+DMAWidth = 8
+
+## Set superblock/page size
+# Superblock/page size will multiplied by each values
+# Leave empty will disable superblock feature
+# Possible values:
+#  C: # Channel
+#  W: # Package/Way
+#  D: # Die
+#  P: # Plane (If multi-plane mode is enabled, P will always applied)
+SuperblockSize = 
+
+## Set page allocation order
+# This order will used when disassembling logical address to physical address
+# Possible values:
+#  C: Channel
+#  W: Package/Way
+#  D: Die
+#  P: Plane
+PageAllocation = CWDP
+
+# Flash Translation Layer Configuration
+[ftl]
+
+## Set mapping method
+# Possible values:
+#  0: Page level mapping
+#  1: FAST mapping
+MappingMode = 1
+
+## Set FTL over-provisioning ratio
+OverProvisioningRatio = 0.25
+
+## Set FTL erase threshold to mark as bad block
+EraseThreshold = 100000
+
+## Filling options
+# Filling Mode
+# Possible values:
+#  0: Sequential filling + Sequential invalidation
+#  1: Sequential filling + Random invalidation
+#  2: Random filling + Random invalidation
+FillingMode = 0
+# FillRatio
+# Fill (warm-up) pages before simulation
+# Set # pages to write (Ratio to total logical pages)
+# 0.0 <= val <= 1.0
+FillRatio = 0
+# InvalidPageRatio
+# Create invalid pages by overwrite filled pages
+# Set # pages to write (Ratio to total logical pages)
+# 0.0 <= val <= 1.0
+InvalidPageRatio = 0.0
+
+## Set victim selection algorithm
+# Possible values:
+#  0: Greedy: Choose least utilized block to clean
+#  1: Cost-Benefit: Choose a block that lowest (Utilization / ((1 - Utilization) * Age))
+#  2: Random: Choose random block
+#  3: D-CHOICE: Choose least utilized block in randomly sampled blocks
+EvictPolicy = 0
+
+## DChoice parameter
+# When sampling blocks, total blocks to erase * DChoiceParam will be selected
+DChoiceParam = 3
+
+## Set garbage collection threshold (ratio of free blocks left)
+GCThreshold = 0.05
+
+## Garbage collection mode
+# Possible values:
+#  0: Reclaim n blocks
+#  1: Reclaim blocks until threshold
+GCMode = 0
+
+## Specify n (Only in GCMode = 0)
+# n > 0
+GCReclaimBlocks = 1
+
+## Specify threshold (Only in GCMode = 1)
+# t > GCThreshold
+GCReclaimThreshold = 0.1
+
+## Random I/O tweak
+# Enable random I/O tweak when using superpage based mapping
+EnableRandomIOTweak = 0
+
+# Internal Cache Layer Configuration
+[icl]
+
+## Set Cache size
+# Cacheline size = physical page size * (multi-plane mode ? plane count : 1)
+# Directed-map cache: Set way as 1
+# Fully-associative cache: Set way value as 0
+CacheSize = 536870912   # 512MiB
+CacheWaySize = 8
+
+## Set read caching (1 for enable)
+EnableReadCache = 0
+
+## Set read prefetching (1 for enable)
+EnableReadPrefetch = 0
+
+## Set prefetch granularity
+# Possible values:
+#  0: One super page
+#  1: One page from all NAND flashes
+ReadPrefetchMode = 0
+
+## Set # of I/O to determine sequential access
+# Value < 1 is invalid
+# 1 means if 2 contiguous I/O is sequential, prefetch will be enabled
+ReadPrefetchCount = 3
+
+## Set size of sequential I/O to determine as sequential access
+# At least (Super page size * ratio) should be accessed as sequential
+# 0 < ratio
+ReadPrefetchRatio = 0.25
+
+## Set write caching (1 for enable)
+EnableWriteCache = 0
+
+## Set cache evict policy
+# Possible values:
+#  0: RANDOM: Evict entry in random fashion
+#  1: FIFO: Evict most oldest entry in selected set
+#  2: LRU: Evict least recently used entry in selected set
+EvictPolicy = 2
+
+## Set cache evict granularity
+# Possible values:
+#  0: One super page
+#  1: One page from all NAND flashes
+EvictMode = 1
+
+## Set cache metadata latency
+# Byte / ps
+CacheLatency = 10
+
+# DRAM configuration
+[dram]
+
+## Select DRAM model to use
+# Possible values:
+#  0: Simple DRAM model based on atomic dram controller of gem5
+Model = 0
+
+## DRAM structure parameters
+Channel = 1
+Rank = 1
+Bank = 8
+Chip = 1
+BusWidth = 32
+BurstLength = 8
+ChipSize = 1073741824
+PageSize = 4096
+
+## DRAM timing parameters (Unit: ps)
+# tCK = 1250
+# tRCD = 13750
+# tCL = 13750
+# tRP = 13750
+# tRAS = 35000
+# tWR = 15000
+# tRTP = 7500
+# tBURST
+# tCCD_L =
+# tRFC = 160000  # 160ns ~ 70200ns
+# tREFI = 7800000
+# tWTR = 7500
+# tRTW =
+# tCS =
+# tRRD = 6000
+# tRRD_L =
+# tXAW =
+# tXP = 6000
+# tXPDLL = 24000
+# tXS = 170000  # tRFC + 10ns
+# tXSDLL = 640000
+
+## DRAM power parameters (Unit: mA or V)
+# IDD0_0 = 40
+# IDD0_1 = 0
+# IDD2P0_0 = 12
+# IDD2P0_1 = 0
+# IDD2P1_0 = 14
+# IDD2P1_1 = 0
+# IDD2N_0 = 21
+# IDD2N_1 = 0
+# IDD3P0_0 = 21
+# IDD3P0_1 = 0
+# IDD3P1_0 = 21
+# IDD3P1_1 = 0
+# IDD3N_0 = 34
+# IDD3N_1 = 0
+# IDD4R_0 = 100
+# IDD4R_1 = 0
+# IDD4W_0 = 105
+# IDD4W_1 = 0
+# IDD5_0 = 182
+# IDD5_1 = 0
+# IDD6_0 = 12
+# IDD6_1 = 0
+# VDD_0 = 1.35
+# VDD_1 = 0
diff --git a/config/page_fill_0.5.cfg b/config/page_fill_0.5.cfg
new file mode 100644
index 0000000..2e9906d
--- /dev/null
+++ b/config/page_fill_0.5.cfg
@@ -0,0 +1,494 @@
+#
+# Copyright (C) 2017 CAMELab
+#
+# This file is part of SimpleSSD.
+#
+# SimpleSSD is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# SimpleSSD is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with SimpleSSD.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+#
+# Sample SimpleSSD Configuration File
+#
+# Section:
+# cpu:  SSD Controller CPU configuration
+# nvme: Non-Volatile Memory Express configuration
+# ufs:  Universal Flash Storage configuration
+# sata: Serial ATA configuration
+# pal:  Parallelism Abstraction Layer configuration
+# ftl:  Flash Translation Layer configuration
+# icl:  Internal Cache Layer configuration
+# dram: DRAM configuration
+#
+
+# SSD Controller CPU configuration
+[cpu]
+## Set clock speed in Hz
+ClockSpeed = 400000000
+
+## Set dedicated core count
+HILCoreCount = 1
+ICLCoreCount = 1
+FTLCoreCount = 1
+
+# NVMe interface Configuration
+[nvme]
+
+## PCI Express Interface
+# Set PCIe generation and lane count
+# Possible values:
+#  0: PCI Express 1.x (2.5GT/s/lane)
+#  1: PCI Express 2.x (5GT/s/lane)
+#  2: PCI Express 3.x (8GT/s/lane)
+PCIEGeneration = 2
+PCIELane = 4
+
+## PCI Express Endpoint <-> NVMe Controller
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 2
+AXIClock = 250000000  # 128bit @ 250MHz -> 4GB/s
+
+## Hardware FIFO Transfer unit
+# Smaller value introduce smaller latency
+FIFOTransferUnit = 2048
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## Set maximum number of I/O queue that controller supports
+# You should check BAR0 size to fit all doorbell
+# Doorbell stride is always 0 (4bytes align)
+MaxIOCQueue = 16
+MaxIOSQueue = 16
+
+## Set parameters of Weighted Round robin
+# Set how many commands should be inserted to internal FIFO
+# before switch to next low priority
+WRRHigh = 2     # Medium-priority command will inserted after two high-priority commands inserted
+WRRMedium = 2   # Low-priority command will inserted after two medium-priority command inserted
+
+## Default Namespace
+# Specify number of namespaces to create
+# Each namespace has same capacity
+DefaultNamespace = 1
+
+## LBA Size
+# Set logical block size of default namespace
+# If DefaultNamespace is false, this value will ignored
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk size check
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+
+## List of disk image path for each namespace
+# e.g. Setting disk image for namespace 2 -> DiskImageFile2 = <image path>
+DiskImageFile1 = nvme.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Universal Flash Storage Configuration
+[ufs]
+
+## AMBA System Bus <-> UFS Host Controller
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 1
+AXIClock = 250000000  # 64bit @ 250MHz -> 2GB/s
+
+## UFS Host Controller <-> UFS Device
+# Set MIPI M-PHY mode and lane count
+# Possible values:
+#  0: HS-G1
+#  1: HS-G2
+#  2: HS-G3
+#  3: HS-G4
+MPHYMode = 2
+MPHYLane = 2
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## LBA Size
+# Set logical block size of default namespace
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk Image Filename
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+DiskImageFile = ufs.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Serial ATA Configuration
+[sata]
+
+## PCI Express Interface
+# Set PCIe generation and lane count
+# Possible values:
+#  0: PCI Express 1.x (2.5GT/s/lane)
+#  1: PCI Express 2.x (5GT/s/lane)
+#  2: PCI Express 3.x (8GT/s/lane)
+PCIEGeneration = 2
+PCIELane = 4
+
+## PCI Express Endpoint <-> NSATA AHCI HBA
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 2
+AXIClock = 250000000  # 128bit @ 250MHz -> 4GB/s
+
+## SATA AHCI HBA <-> SATA Device
+# Set SATA generation
+# Possible values:
+#  0: SATA 1.0 (1.5Gbps)
+#  1: SATA 2.0 (3Gbps)
+#  2: SATA 3.0 (6Gbps)
+SATAMode = 2
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## LBA Size
+# Set logical block size of default namespace
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk Image Filename
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+DiskImageFile = sata.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Parallelism Abstraction Layer Configuration
+[pal]
+
+## Set SSD structure
+#  Channel: # of channels in SSD
+#  Package: # of packages in one channel
+Channel = 8
+Package = 4
+
+## Set NAND package structure
+#  Die:      # of die in one package
+#  Plane:    # of plane in one die
+#  Block:    # of block in one plane
+#  Page:     # of page in one block
+#  PageSize: Size of one page in byte
+Die = 4
+Plane = 1
+Block = 512
+Page = 512
+PageSize = 4096
+
+## Multi-plane operation
+# 1 for enable multi-plane operation
+EnableMultiPlaneOperation = 1
+
+## Set type of NAND flash
+# Possible values:
+#  0: Single Level Cell
+#  1: Multi Level Cell
+#  2: Triple Level Cell
+# Please check NAND timing has valid values
+#  SLC: LSB timing should valid
+#  MLC: LSB and MSB timing should valid
+#  TLC: LSB, CSB and MSB timing should valid
+NANDType = 1
+
+## Set NAND timing
+LSBRead = 40000000
+LSBWrite = 500000000
+CSBRead = 0
+CSBWrite = 0
+MSBRead = 65000000
+MSBWrite = 1300000000
+Erase = 3500000000
+
+## Set speed and width of DMA in channel in MT/s
+# Width should be 8 or 16
+# Typical values from ONFi:
+#         ONFi   1.x     2.x   3.x~4.x    4.x
+#  Timing Mode   SDR   NV-DDR  NV-DDR2  NV-DDR3
+#      0         10      40      67       67
+#      1         20      67      80       80
+#      2         29     100     133      133
+#      3         33     133     167      167
+#      4         40     167     200      200
+#      5         50     200     267      267
+#      6          -       -     333      333
+#      7          -       -     400      400
+#      8          -       -     533      533
+#      9          -       -       -      667
+#     10          -       -       -      800
+DMASpeed = 400
+DMAWidth = 8
+
+## Set superblock/page size
+# Superblock/page size will multiplied by each values
+# Leave empty will disable superblock feature
+# Possible values:
+#  C: # Channel
+#  W: # Package/Way
+#  D: # Die
+#  P: # Plane (If multi-plane mode is enabled, P will always applied)
+SuperblockSize = 
+
+## Set page allocation order
+# This order will used when disassembling logical address to physical address
+# Possible values:
+#  C: Channel
+#  W: Package/Way
+#  D: Die
+#  P: Plane
+PageAllocation = CWDP
+
+# Flash Translation Layer Configuration
+[ftl]
+
+## Set mapping method
+# Possible values:
+#  0: Page level mapping
+#  1: FAST mapping
+MappingMode = 0
+
+## Set FTL over-provisioning ratio
+OverProvisioningRatio = 0.25
+
+## Set FTL erase threshold to mark as bad block
+EraseThreshold = 100000
+
+## Filling options
+# Filling Mode
+# Possible values:
+#  0: Sequential filling + Sequential invalidation
+#  1: Sequential filling + Random invalidation
+#  2: Random filling + Random invalidation
+FillingMode = 0
+# FillRatio
+# Fill (warm-up) pages before simulation
+# Set # pages to write (Ratio to total logical pages)
+# 0.0 <= val <= 1.0
+FillRatio = 0.5
+# InvalidPageRatio
+# Create invalid pages by overwrite filled pages
+# Set # pages to write (Ratio to total logical pages)
+# 0.0 <= val <= 1.0
+InvalidPageRatio = 0.0
+
+## Set victim selection algorithm
+# Possible values:
+#  0: Greedy: Choose least utilized block to clean
+#  1: Cost-Benefit: Choose a block that lowest (Utilization / ((1 - Utilization) * Age))
+#  2: Random: Choose random block
+#  3: D-CHOICE: Choose least utilized block in randomly sampled blocks
+EvictPolicy = 0
+
+## DChoice parameter
+# When sampling blocks, total blocks to erase * DChoiceParam will be selected
+DChoiceParam = 3
+
+## Set garbage collection threshold (ratio of free blocks left)
+GCThreshold = 0.05
+
+## Garbage collection mode
+# Possible values:
+#  0: Reclaim n blocks
+#  1: Reclaim blocks until threshold
+GCMode = 0
+
+## Specify n (Only in GCMode = 0)
+# n > 0
+GCReclaimBlocks = 1
+
+## Specify threshold (Only in GCMode = 1)
+# t > GCThreshold
+GCReclaimThreshold = 0.1
+
+## Random I/O tweak
+# Enable random I/O tweak when using superpage based mapping
+EnableRandomIOTweak = 0
+
+# Internal Cache Layer Configuration
+[icl]
+
+## Set Cache size
+# Cacheline size = physical page size * (multi-plane mode ? plane count : 1)
+# Directed-map cache: Set way as 1
+# Fully-associative cache: Set way value as 0
+CacheSize = 536870912   # 512MiB
+CacheWaySize = 8
+
+## Set read caching (1 for enable)
+EnableReadCache = 0
+
+## Set read prefetching (1 for enable)
+EnableReadPrefetch = 0
+
+## Set prefetch granularity
+# Possible values:
+#  0: One super page
+#  1: One page from all NAND flashes
+ReadPrefetchMode = 0
+
+## Set # of I/O to determine sequential access
+# Value < 1 is invalid
+# 1 means if 2 contiguous I/O is sequential, prefetch will be enabled
+ReadPrefetchCount = 3
+
+## Set size of sequential I/O to determine as sequential access
+# At least (Super page size * ratio) should be accessed as sequential
+# 0 < ratio
+ReadPrefetchRatio = 0.25
+
+## Set write caching (1 for enable)
+EnableWriteCache = 0
+
+## Set cache evict policy
+# Possible values:
+#  0: RANDOM: Evict entry in random fashion
+#  1: FIFO: Evict most oldest entry in selected set
+#  2: LRU: Evict least recently used entry in selected set
+EvictPolicy = 2
+
+## Set cache evict granularity
+# Possible values:
+#  0: One super page
+#  1: One page from all NAND flashes
+EvictMode = 1
+
+## Set cache metadata latency
+# Byte / ps
+CacheLatency = 10
+
+# DRAM configuration
+[dram]
+
+## Select DRAM model to use
+# Possible values:
+#  0: Simple DRAM model based on atomic dram controller of gem5
+Model = 0
+
+## DRAM structure parameters
+Channel = 1
+Rank = 1
+Bank = 8
+Chip = 1
+BusWidth = 32
+BurstLength = 8
+ChipSize = 1073741824
+PageSize = 4096
+
+## DRAM timing parameters (Unit: ps)
+# tCK = 1250
+# tRCD = 13750
+# tCL = 13750
+# tRP = 13750
+# tRAS = 35000
+# tWR = 15000
+# tRTP = 7500
+# tBURST
+# tCCD_L =
+# tRFC = 160000  # 160ns ~ 70200ns
+# tREFI = 7800000
+# tWTR = 7500
+# tRTW =
+# tCS =
+# tRRD = 6000
+# tRRD_L =
+# tXAW =
+# tXP = 6000
+# tXPDLL = 24000
+# tXS = 170000  # tRFC + 10ns
+# tXSDLL = 640000
+
+## DRAM power parameters (Unit: mA or V)
+# IDD0_0 = 40
+# IDD0_1 = 0
+# IDD2P0_0 = 12
+# IDD2P0_1 = 0
+# IDD2P1_0 = 14
+# IDD2P1_1 = 0
+# IDD2N_0 = 21
+# IDD2N_1 = 0
+# IDD3P0_0 = 21
+# IDD3P0_1 = 0
+# IDD3P1_0 = 21
+# IDD3P1_1 = 0
+# IDD3N_0 = 34
+# IDD3N_1 = 0
+# IDD4R_0 = 100
+# IDD4R_1 = 0
+# IDD4W_0 = 105
+# IDD4W_1 = 0
+# IDD5_0 = 182
+# IDD5_1 = 0
+# IDD6_0 = 12
+# IDD6_1 = 0
+# VDD_0 = 1.35
+# VDD_1 = 0
diff --git a/config/page_fill_0.cfg b/config/page_fill_0.cfg
new file mode 100644
index 0000000..5cf8248
--- /dev/null
+++ b/config/page_fill_0.cfg
@@ -0,0 +1,494 @@
+#
+# Copyright (C) 2017 CAMELab
+#
+# This file is part of SimpleSSD.
+#
+# SimpleSSD is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# SimpleSSD is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with SimpleSSD.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+#
+# Sample SimpleSSD Configuration File
+#
+# Section:
+# cpu:  SSD Controller CPU configuration
+# nvme: Non-Volatile Memory Express configuration
+# ufs:  Universal Flash Storage configuration
+# sata: Serial ATA configuration
+# pal:  Parallelism Abstraction Layer configuration
+# ftl:  Flash Translation Layer configuration
+# icl:  Internal Cache Layer configuration
+# dram: DRAM configuration
+#
+
+# SSD Controller CPU configuration
+[cpu]
+## Set clock speed in Hz
+ClockSpeed = 400000000
+
+## Set dedicated core count
+HILCoreCount = 1
+ICLCoreCount = 1
+FTLCoreCount = 1
+
+# NVMe interface Configuration
+[nvme]
+
+## PCI Express Interface
+# Set PCIe generation and lane count
+# Possible values:
+#  0: PCI Express 1.x (2.5GT/s/lane)
+#  1: PCI Express 2.x (5GT/s/lane)
+#  2: PCI Express 3.x (8GT/s/lane)
+PCIEGeneration = 2
+PCIELane = 4
+
+## PCI Express Endpoint <-> NVMe Controller
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 2
+AXIClock = 250000000  # 128bit @ 250MHz -> 4GB/s
+
+## Hardware FIFO Transfer unit
+# Smaller value introduce smaller latency
+FIFOTransferUnit = 2048
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## Set maximum number of I/O queue that controller supports
+# You should check BAR0 size to fit all doorbell
+# Doorbell stride is always 0 (4bytes align)
+MaxIOCQueue = 16
+MaxIOSQueue = 16
+
+## Set parameters of Weighted Round robin
+# Set how many commands should be inserted to internal FIFO
+# before switch to next low priority
+WRRHigh = 2     # Medium-priority command will inserted after two high-priority commands inserted
+WRRMedium = 2   # Low-priority command will inserted after two medium-priority command inserted
+
+## Default Namespace
+# Specify number of namespaces to create
+# Each namespace has same capacity
+DefaultNamespace = 1
+
+## LBA Size
+# Set logical block size of default namespace
+# If DefaultNamespace is false, this value will ignored
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk size check
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+
+## List of disk image path for each namespace
+# e.g. Setting disk image for namespace 2 -> DiskImageFile2 = <image path>
+DiskImageFile1 = nvme.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Universal Flash Storage Configuration
+[ufs]
+
+## AMBA System Bus <-> UFS Host Controller
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 1
+AXIClock = 250000000  # 64bit @ 250MHz -> 2GB/s
+
+## UFS Host Controller <-> UFS Device
+# Set MIPI M-PHY mode and lane count
+# Possible values:
+#  0: HS-G1
+#  1: HS-G2
+#  2: HS-G3
+#  3: HS-G4
+MPHYMode = 2
+MPHYLane = 2
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## LBA Size
+# Set logical block size of default namespace
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk Image Filename
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+DiskImageFile = ufs.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Serial ATA Configuration
+[sata]
+
+## PCI Express Interface
+# Set PCIe generation and lane count
+# Possible values:
+#  0: PCI Express 1.x (2.5GT/s/lane)
+#  1: PCI Express 2.x (5GT/s/lane)
+#  2: PCI Express 3.x (8GT/s/lane)
+PCIEGeneration = 2
+PCIELane = 4
+
+## PCI Express Endpoint <-> NSATA AHCI HBA
+# Set bus width and clock speed of AXI-Stream interface
+# Possible values:
+#  0: 32Bit
+#  1: 64Bit
+#  2: 128Bit
+#  3: 256Bit
+#  4: 512Bit
+#  5: 1024Bit
+AXIBusWidth = 2
+AXIClock = 250000000  # 128bit @ 250MHz -> 4GB/s
+
+## SATA AHCI HBA <-> SATA Device
+# Set SATA generation
+# Possible values:
+#  0: SATA 1.0 (1.5Gbps)
+#  1: SATA 2.0 (3Gbps)
+#  2: SATA 3.0 (6Gbps)
+SATAMode = 2
+
+## Set interval for controller main loop
+WorkInterval = 1000000  # 1us
+
+## Maximum # of I/O request handling on one loop
+MaxRequestCount = 8
+
+## LBA Size
+# Set logical block size of default namespace
+LBASize = 512
+
+## Enable Disk Image
+# 1 for enable I/O to disk image
+# 0 for disable disk image
+EnableDiskImage = 0
+
+## Disk Image Filename
+# If EnableDiskImage is 1, and no file exists, file with size of SSD will created
+# If StrictSizeCheck is 1, disk file exists, and size of disk image is not equal to SSD size, it makes error
+StrictSizeCheck = 0
+DiskImageFile = sata.img
+
+## Copy-on-Write Disk
+# 0 for use normal disk
+# 1 for use Copy-on-write disk (Write to disk will not affect disk image file)
+UseCopyOnWriteDisk = 0
+
+# Parallelism Abstraction Layer Configuration
+[pal]
+
+## Set SSD structure
+#  Channel: # of channels in SSD
+#  Package: # of packages in one channel
+Channel = 8
+Package = 4
+
+## Set NAND package structure
+#  Die:      # of die in one package
+#  Plane:    # of plane in one die
+#  Block:    # of block in one plane
+#  Page:     # of page in one block
+#  PageSize: Size of one page in byte
+Die = 4
+Plane = 1
+Block = 512
+Page = 512
+PageSize = 4096
+
+## Multi-plane operation
+# 1 for enable multi-plane operation
+EnableMultiPlaneOperation = 1
+
+## Set type of NAND flash
+# Possible values:
+#  0: Single Level Cell
+#  1: Multi Level Cell
+#  2: Triple Level Cell
+# Please check NAND timing has valid values
+#  SLC: LSB timing should valid
+#  MLC: LSB and MSB timing should valid
+#  TLC: LSB, CSB and MSB timing should valid
+NANDType = 1
+
+## Set NAND timing
+LSBRead = 40000000
+LSBWrite = 500000000
+CSBRead = 0
+CSBWrite = 0
+MSBRead = 65000000
+MSBWrite = 1300000000
+Erase = 3500000000
+
+## Set speed and width of DMA in channel in MT/s
+# Width should be 8 or 16
+# Typical values from ONFi:
+#         ONFi   1.x     2.x   3.x~4.x    4.x
+#  Timing Mode   SDR   NV-DDR  NV-DDR2  NV-DDR3
+#      0         10      40      67       67
+#      1         20      67      80       80
+#      2         29     100     133      133
+#      3         33     133     167      167
+#      4         40     167     200      200
+#      5         50     200     267      267
+#      6          -       -     333      333
+#      7          -       -     400      400
+#      8          -       -     533      533
+#      9          -       -       -      667
+#     10          -       -       -      800
+DMASpeed = 400
+DMAWidth = 8
+
+## Set superblock/page size
+# Superblock/page size will multiplied by each values
+# Leave empty will disable superblock feature
+# Possible values:
+#  C: # Channel
+#  W: # Package/Way
+#  D: # Die
+#  P: # Plane (If multi-plane mode is enabled, P will always applied)
+SuperblockSize = 
+
+## Set page allocation order
+# This order will used when disassembling logical address to physical address
+# Possible values:
+#  C: Channel
+#  W: Package/Way
+#  D: Die
+#  P: Plane
+PageAllocation = CWDP
+
+# Flash Translation Layer Configuration
+[ftl]
+
+## Set mapping method
+# Possible values:
+#  0: Page level mapping
+#  1: FAST mapping
+MappingMode = 0
+
+## Set FTL over-provisioning ratio
+OverProvisioningRatio = 0.25
+
+## Set FTL erase threshold to mark as bad block
+EraseThreshold = 100000
+
+## Filling options
+# Filling Mode
+# Possible values:
+#  0: Sequential filling + Sequential invalidation
+#  1: Sequential filling + Random invalidation
+#  2: Random filling + Random invalidation
+FillingMode = 0
+# FillRatio
+# Fill (warm-up) pages before simulation
+# Set # pages to write (Ratio to total logical pages)
+# 0.0 <= val <= 1.0
+FillRatio = 0
+# InvalidPageRatio
+# Create invalid pages by overwrite filled pages
+# Set # pages to write (Ratio to total logical pages)
+# 0.0 <= val <= 1.0
+InvalidPageRatio = 0.0
+
+## Set victim selection algorithm
+# Possible values:
+#  0: Greedy: Choose least utilized block to clean
+#  1: Cost-Benefit: Choose a block that lowest (Utilization / ((1 - Utilization) * Age))
+#  2: Random: Choose random block
+#  3: D-CHOICE: Choose least utilized block in randomly sampled blocks
+EvictPolicy = 0
+
+## DChoice parameter
+# When sampling blocks, total blocks to erase * DChoiceParam will be selected
+DChoiceParam = 3
+
+## Set garbage collection threshold (ratio of free blocks left)
+GCThreshold = 0.05
+
+## Garbage collection mode
+# Possible values:
+#  0: Reclaim n blocks
+#  1: Reclaim blocks until threshold
+GCMode = 0
+
+## Specify n (Only in GCMode = 0)
+# n > 0
+GCReclaimBlocks = 1
+
+## Specify threshold (Only in GCMode = 1)
+# t > GCThreshold
+GCReclaimThreshold = 0.1
+
+## Random I/O tweak
+# Enable random I/O tweak when using superpage based mapping
+EnableRandomIOTweak = 0
+
+# Internal Cache Layer Configuration
+[icl]
+
+## Set Cache size
+# Cacheline size = physical page size * (multi-plane mode ? plane count : 1)
+# Directed-map cache: Set way as 1
+# Fully-associative cache: Set way value as 0
+CacheSize = 536870912   # 512MiB
+CacheWaySize = 8
+
+## Set read caching (1 for enable)
+EnableReadCache = 0
+
+## Set read prefetching (1 for enable)
+EnableReadPrefetch = 0
+
+## Set prefetch granularity
+# Possible values:
+#  0: One super page
+#  1: One page from all NAND flashes
+ReadPrefetchMode = 0
+
+## Set # of I/O to determine sequential access
+# Value < 1 is invalid
+# 1 means if 2 contiguous I/O is sequential, prefetch will be enabled
+ReadPrefetchCount = 3
+
+## Set size of sequential I/O to determine as sequential access
+# At least (Super page size * ratio) should be accessed as sequential
+# 0 < ratio
+ReadPrefetchRatio = 0.25
+
+## Set write caching (1 for enable)
+EnableWriteCache = 0
+
+## Set cache evict policy
+# Possible values:
+#  0: RANDOM: Evict entry in random fashion
+#  1: FIFO: Evict most oldest entry in selected set
+#  2: LRU: Evict least recently used entry in selected set
+EvictPolicy = 2
+
+## Set cache evict granularity
+# Possible values:
+#  0: One super page
+#  1: One page from all NAND flashes
+EvictMode = 1
+
+## Set cache metadata latency
+# Byte / ps
+CacheLatency = 10
+
+# DRAM configuration
+[dram]
+
+## Select DRAM model to use
+# Possible values:
+#  0: Simple DRAM model based on atomic dram controller of gem5
+Model = 0
+
+## DRAM structure parameters
+Channel = 1
+Rank = 1
+Bank = 8
+Chip = 1
+BusWidth = 32
+BurstLength = 8
+ChipSize = 1073741824
+PageSize = 4096
+
+## DRAM timing parameters (Unit: ps)
+# tCK = 1250
+# tRCD = 13750
+# tCL = 13750
+# tRP = 13750
+# tRAS = 35000
+# tWR = 15000
+# tRTP = 7500
+# tBURST
+# tCCD_L =
+# tRFC = 160000  # 160ns ~ 70200ns
+# tREFI = 7800000
+# tWTR = 7500
+# tRTW =
+# tCS =
+# tRRD = 6000
+# tRRD_L =
+# tXAW =
+# tXP = 6000
+# tXPDLL = 24000
+# tXS = 170000  # tRFC + 10ns
+# tXSDLL = 640000
+
+## DRAM power parameters (Unit: mA or V)
+# IDD0_0 = 40
+# IDD0_1 = 0
+# IDD2P0_0 = 12
+# IDD2P0_1 = 0
+# IDD2P1_0 = 14
+# IDD2P1_1 = 0
+# IDD2N_0 = 21
+# IDD2N_1 = 0
+# IDD3P0_0 = 21
+# IDD3P0_1 = 0
+# IDD3P1_0 = 21
+# IDD3P1_1 = 0
+# IDD3N_0 = 34
+# IDD3N_1 = 0
+# IDD4R_0 = 100
+# IDD4R_1 = 0
+# IDD4W_0 = 105
+# IDD4W_1 = 0
+# IDD5_0 = 182
+# IDD5_1 = 0
+# IDD6_0 = 12
+# IDD6_1 = 0
+# VDD_0 = 1.35
+# VDD_1 = 0
diff --git a/config/sample.cfg b/config/sample.cfg
index e9da395..0038c2c 100644
--- a/config/sample.cfg
+++ b/config/sample.cfg
@@ -240,11 +240,11 @@ Package = 4
 #  Block:    # of block in one plane
 #  Page:     # of page in one block
 #  PageSize: Size of one page in byte
-Die = 2
-Plane = 2
+Die = 4
+Plane = 1
 Block = 512
 Page = 512
-PageSize = 16384
+PageSize = 4096
 
 ## Multi-plane operation
 # 1 for enable multi-plane operation
@@ -297,7 +297,7 @@ DMAWidth = 8
 #  W: # Package/Way
 #  D: # Die
 #  P: # Plane (If multi-plane mode is enabled, P will always applied)
-SuperblockSize = C
+SuperblockSize = 
 
 ## Set page allocation order
 # This order will used when disassembling logical address to physical address
@@ -314,6 +314,7 @@ PageAllocation = CWDP
 ## Set mapping method
 # Possible values:
 #  0: Page level mapping
+#  1: FAST mapping
 MappingMode = 0
 
 ## Set FTL over-provisioning ratio
@@ -333,7 +334,7 @@ FillingMode = 0
 # Fill (warm-up) pages before simulation
 # Set # pages to write (Ratio to total logical pages)
 # 0.0 <= val <= 1.0
-FillRatio = 0.0
+FillRatio = 0.65
 # InvalidPageRatio
 # Create invalid pages by overwrite filled pages
 # Set # pages to write (Ratio to total logical pages)
@@ -371,7 +372,7 @@ GCReclaimThreshold = 0.1
 
 ## Random I/O tweak
 # Enable random I/O tweak when using superpage based mapping
-EnableRandomIOTweak = 1
+EnableRandomIOTweak = 0
 
 # Internal Cache Layer Configuration
 [icl]
@@ -384,16 +385,16 @@ CacheSize = 536870912   # 512MiB
 CacheWaySize = 8
 
 ## Set read caching (1 for enable)
-EnableReadCache = 1
+EnableReadCache = 0
 
 ## Set read prefetching (1 for enable)
-EnableReadPrefetch = 1
+EnableReadPrefetch = 0
 
 ## Set prefetch granularity
 # Possible values:
 #  0: One super page
 #  1: One page from all NAND flashes
-ReadPrefetchMode = 1
+ReadPrefetchMode = 0
 
 ## Set # of I/O to determine sequential access
 # Value < 1 is invalid
@@ -406,7 +407,7 @@ ReadPrefetchCount = 3
 ReadPrefetchRatio = 0.25
 
 ## Set write caching (1 for enable)
-EnableWriteCache = 1
+EnableWriteCache = 0
 
 ## Set cache evict policy
 # Possible values:
diff --git a/ftl/common/block.cc b/ftl/common/block.cc
index d7be114..ddd176f 100644
--- a/ftl/common/block.cc
+++ b/ftl/common/block.cc
@@ -21,6 +21,8 @@
 
 #include <algorithm>
 #include <cstring>
+#include <cassert>
+#include "block.hh"
 
 namespace SimpleSSD {
 
@@ -271,6 +273,30 @@ bool Block::getPageInfo(uint32_t pageIndex, std::vector<uint64_t> &lpn,
   return map.any();
 }
 
+
+void Block::getPageInfo(uint32_t pageIndex, uint64_t &lpn, bool &valid, bool &erased) {
+  assert(pageIndex < pageCount);
+  lpn = pLPNs[pageIndex];
+  valid = pValidBits->test(pageIndex);
+  erased = pErasedBits->test(pageIndex);
+}
+
+uint32_t Block::getErasedPageCount() {
+  return pErasedBits->count();
+}
+
+uint32_t Block::getLPN(uint32_t pageIndex) {
+  return pLPNs[pageIndex];
+}
+
+bool Block::isValid(uint32_t pageIndex) {
+  return pValidBits->test(pageIndex);
+}
+
+bool Block::isCleanBlock() {
+  return getErasedPageCount() == pageCount;
+}
+
 bool Block::read(uint32_t pageIndex, uint32_t idx, uint64_t tick) {
   bool read = false;
 
@@ -306,9 +332,9 @@ bool Block::write(uint32_t pageIndex, uint64_t lpn, uint32_t idx,
   }
 
   if (write) {
-    if (pageIndex < pNextWritePageIndex[idx]) {
-      panic("Write to block should sequential");
-    }
+    // if (pageIndex < pNextWritePageIndex[idx]) {
+    //   panic("Write to block should sequential");
+    // }
 
     lastAccessed = tick;
 
diff --git a/ftl/common/block.hh b/ftl/common/block.hh
index edceb4a..b1368f3 100644
--- a/ftl/common/block.hh
+++ b/ftl/common/block.hh
@@ -66,7 +66,17 @@ class Block {
   uint32_t getDirtyPageCount();
   uint32_t getNextWritePageIndex();
   uint32_t getNextWritePageIndex(uint32_t);
+  bool isCleanBlock();
+
+
   bool getPageInfo(uint32_t, std::vector<uint64_t> &, Bitset &);
+
+  // only for simple non-superpage case.
+  void getPageInfo(uint32_t, uint64_t &, bool &, bool &);
+  uint32_t getErasedPageCount();
+  uint32_t getLPN(uint32_t);
+  bool isValid(uint32_t);
+  
   bool read(uint32_t, uint32_t, uint64_t);
   bool write(uint32_t, uint64_t, uint32_t, uint64_t);
   void erase();
diff --git a/ftl/config.hh b/ftl/config.hh
index e3e923f..e8efd74 100644
--- a/ftl/config.hh
+++ b/ftl/config.hh
@@ -49,6 +49,7 @@ typedef enum {
 
 typedef enum {
   PAGE_MAPPING,
+  FAST_MAPPING,
 } MAPPING;
 
 typedef enum {
diff --git a/ftl/fast_mapping.cc b/ftl/fast_mapping.cc
new file mode 100644
index 0000000..e1b6981
--- /dev/null
+++ b/ftl/fast_mapping.cc
@@ -0,0 +1,821 @@
+/*
+ * Copyright (C) 2017 CAMELab
+ *
+ * This file is part of SimpleSSD.
+ *
+ * SimpleSSD is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * SimpleSSD is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with SimpleSSD.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "ftl/fast_mapping.hh"
+
+#include <algorithm>
+#include <limits>
+#include <random>
+
+#include "util/algorithm.hh"
+#include "util/bitset.hh"
+#include "fast_mapping.hh"
+
+namespace SimpleSSD {
+
+namespace FTL {
+
+
+FastMapping::FastMapping(ConfigReader &c, Parameter &p, PAL::PAL *l,
+                         DRAM::AbstractDRAM *d)
+    : AbstractFTL(p, l, d),
+      pPAL(l),
+      conf(c) {
+
+  assert(param.totalPhysicalBlocks > 1u + this->kRWBlockCnt);
+        
+  this->physicalBlocks.reserve(param.totalPhysicalBlocks);
+  this->logicalToPhysicalBlockMapping.resize(param.totalLogicalBlocks);
+  this->physicalToLogicalBlockMapping.resize(param.totalPhysicalBlocks);
+
+
+  // init physicalBlocks
+  for (uint32_t i = 0; i < param.totalPhysicalBlocks; i++) {
+    this->physicalBlocks.emplace_back(Block(i, param.pagesInBlock, param.ioUnitInPage));
+  }
+  
+  this->SWBlock = 0;
+  for (uint32_t i = 1; i <= this->kRWBlockCnt; i++) {
+    this->RWBlocks.emplace_back(i);
+  }
+  for (uint32_t i = this->kRWBlockCnt + 1; i < param.totalPhysicalBlocks; i++) {
+    freeBlocks.emplace_back(i);
+  }
+
+  status.totalLogicalPages = param.totalLogicalBlocks * param.pagesInBlock;
+  
+  memset(&stat, 0, sizeof(stat));
+
+  bool bRandomTweak = conf.readBoolean(CONFIG_FTL, FTL_USE_RANDOM_IO_TWEAK);
+  assert(bRandomTweak == false);
+}
+
+FastMapping::~FastMapping() {}
+
+bool FastMapping::initialize() {
+  uint64_t nPagesToWarmup;
+  uint64_t nPagesToInvalidate;
+  uint64_t nTotalLogicalPages;
+  uint64_t tick;
+  uint64_t valid;
+  uint64_t invalid;
+  FILLING_MODE mode;
+
+  Request req(param.ioUnitInPage);
+
+  debugprint(LOG_FTL_FAST_MAPPING, "Initialization started");
+
+  nTotalLogicalPages = param.totalLogicalBlocks * param.pagesInBlock;
+  nPagesToWarmup =
+      nTotalLogicalPages * conf.readFloat(CONFIG_FTL, FTL_FILL_RATIO);
+  nPagesToInvalidate =
+      nTotalLogicalPages * conf.readFloat(CONFIG_FTL, FTL_INVALID_PAGE_RATIO);
+
+  // Warn: the feature of pre-invalidating pages is not tested yet.
+  assert(nPagesToInvalidate == 0); 
+
+  mode = (FILLING_MODE)conf.readUint(CONFIG_FTL, FTL_FILLING_MODE);
+
+  debugprint(LOG_FTL_FAST_MAPPING, "Total logical pages: %" PRIu64,
+             nTotalLogicalPages);
+  debugprint(LOG_FTL_FAST_MAPPING,
+             "Total logical pages to fill: %" PRIu64 " (%.2f %%)",
+             nPagesToWarmup, nPagesToWarmup * 100.f / nTotalLogicalPages);
+  debugprint(LOG_FTL_FAST_MAPPING,
+             "Total invalidated pages to create: %" PRIu64 " (%.2f %%)",
+             nPagesToInvalidate,
+             nPagesToInvalidate * 100.f / nTotalLogicalPages);
+
+  req.ioFlag.set();
+
+  // Step 1. Filling
+  if (mode == FILLING_MODE_0 || mode == FILLING_MODE_1) {
+    // Sequential
+    for (uint64_t i = 0; i < nPagesToWarmup; i++) {
+      tick = 0;
+      req.lpn = i;
+      writeInternal(req, tick, false);
+    }
+  }
+  else {
+    // Random
+    std::random_device rd;
+    std::mt19937_64 gen(rd());
+    std::uniform_int_distribution<uint64_t> dist(0, nTotalLogicalPages - 1);
+
+    for (uint64_t i = 0; i < nPagesToWarmup; i++) {
+      tick = 0;
+      req.lpn = dist(gen);
+      writeInternal(req, tick, false);
+    }
+  }
+
+  // Step 2. Invalidating
+  if (mode == FILLING_MODE_0) {
+    // Sequential
+    for (uint64_t i = 0; i < nPagesToInvalidate; i++) {
+      tick = 0;
+      req.lpn = i;
+      writeInternal(req, tick, false);
+    }
+  }
+  else if (mode == FILLING_MODE_1) {
+    // Random
+    // We can successfully restrict range of LPN to create exact number of
+    // invalid pages because we wrote in sequential mannor in step 1.
+    std::random_device rd;
+    std::mt19937_64 gen(rd());
+    std::uniform_int_distribution<uint64_t> dist(0, nPagesToWarmup - 1);
+
+    for (uint64_t i = 0; i < nPagesToInvalidate; i++) {
+      tick = 0;
+      req.lpn = dist(gen);
+      writeInternal(req, tick, false);
+    }
+  }
+  else {
+    // Random
+    std::random_device rd;
+    std::mt19937_64 gen(rd());
+    std::uniform_int_distribution<uint64_t> dist(0, nTotalLogicalPages - 1);
+
+    for (uint64_t i = 0; i < nPagesToInvalidate; i++) {
+      tick = 0;
+      req.lpn = dist(gen);
+      writeInternal(req, tick, false);
+    }
+  }
+
+  // Report
+  calculateTotalPages(valid, invalid);
+  debugprint(LOG_FTL_FAST_MAPPING, "Filling finished. Page status:");
+  debugprint(LOG_FTL_FAST_MAPPING,
+             "  Total valid physical pages: %" PRIu64
+             " (%.2f %%, target: %" PRIu64 ", error: %" PRId64 ")",
+             valid, valid * 100.f / nTotalLogicalPages, nPagesToWarmup,
+             (int64_t)(valid - nPagesToWarmup));
+  debugprint(LOG_FTL_FAST_MAPPING,
+             "  Total invalid physical pages: %" PRIu64
+             " (%.2f %%, target: %" PRIu64 ", error: %" PRId64 ")",
+             invalid, invalid * 100.f / nTotalLogicalPages, nPagesToInvalidate,
+             (int64_t)(invalid - nPagesToInvalidate));
+  debugprint(LOG_FTL_FAST_MAPPING, "Initialization finished");
+
+  return true;
+}
+
+uint32_t FastMapping::convertPageToBlock(uint64_t page_number) {
+  return page_number / param.pagesInBlock;
+}
+
+uint64_t FastMapping::convertPageToOffsetInBlock(uint64_t page_number) {
+  return page_number % param.pagesInBlock;
+}
+
+void FastMapping::read(Request &req, uint64_t &tick) {
+  uint64_t begin = tick;
+
+  if (req.ioFlag.count() > 0) {
+    readInternal(req, tick);
+
+    debugprint(LOG_FTL_FAST_MAPPING,
+               "READ  | LPN %" PRIu64 " | %" PRIu64 " - %" PRIu64 " (%" PRIu64
+               ")",
+               req.lpn, begin, tick, tick - begin);
+  }
+  else {
+    warn("FTL got empty request");
+  }
+
+  tick += applyLatency(CPU::FTL__PAGE_MAPPING, CPU::READ);
+}
+
+void FastMapping::write(Request &req, uint64_t &tick) {
+  uint64_t begin = tick;
+
+  if (req.ioFlag.count() > 0) {
+    writeInternal(req, tick);
+
+    debugprint(LOG_FTL_FAST_MAPPING,
+               "WRITE | LPN %" PRIu64 " | %" PRIu64 " - %" PRIu64 " (%" PRIu64
+               ")",
+               req.lpn, begin, tick, tick - begin);
+  }
+  else {
+    warn("FTL got empty request");
+  }
+
+  tick += applyLatency(CPU::FTL__PAGE_MAPPING, CPU::WRITE);
+}
+
+void FastMapping::trim(Request &req, uint64_t &tick) {
+  (void) req, (void) tick;
+  assert(0); // not implemented yet.
+}
+
+void FastMapping::format(LPNRange &range, uint64_t &tick) {
+  (void) range, (void) tick;
+  assert(0); // not implemented yet.
+}
+
+Status *FastMapping::getStatus(uint64_t lpnBegin, uint64_t lpnEnd) {
+  (void) lpnBegin, (void) lpnEnd;
+  assert(0); // not implemented yet.
+}
+
+float FastMapping::freeBlockRatio() {
+  return (float)freeBlocks.size() / param.totalPhysicalBlocks;
+}
+
+void FastMapping::eraseInternal(uint32_t physicalBlockNum, uint64_t &tick, bool sendToPAL) {
+
+  
+  Block &block = physicalBlocks[physicalBlockNum];
+  block.erase();
+
+  if (sendToPAL) {
+    PAL::Request req(1);
+    req.blockIndex = physicalBlockNum;
+    req.pageIndex = 0;
+    req.ioFlag.set();
+    pPAL->erase(req, tick); // tick += ...
+  }
+
+  physicalToLogicalBlockMapping[physicalBlockNum] = std::nullopt;
+
+  // static uint64_t threshold =
+  //     conf.readUint(CONFIG_FTL, FTL_BAD_BLOCK_THRESHOLD);
+  // wear leveling check: disable now.
+  // if (block.getEraseCount() < threshold) {
+  //   freeBlocks.emplace_back(physicalBlockNum);
+  // }
+
+  tick += applyLatency(CPU::FTL__PAGE_MAPPING, CPU::ERASE_INTERNAL);
+}
+
+uint32_t FastMapping::getFreeBlock() {
+  if (freeBlocks.empty()) {
+    panic("No free block");
+  }
+
+  auto ret = freeBlocks.front();
+  freeBlocks.pop_front();
+  return ret;
+}
+
+void FastMapping::readInternal(Request &req, uint64_t &tick) {
+  PAL::Request palRequest(req);
+
+  uint32_t pbn;
+  uint32_t pageIdx;
+  Block *pBlock;
+  BlockType blockType;
+
+  if (findValidPage(req.lpn, pbn, pageIdx, pBlock, blockType)) {
+    pBlock->read(pageIdx, 0, tick); // tick stays
+
+    palRequest.blockIndex = pbn;
+    palRequest.pageIndex = pageIdx;
+    palRequest.ioFlag = req.ioFlag;
+
+    pPAL->read(palRequest, tick); // tick += ...
+  } else {
+    // panic("No valid page found");
+    // page_mapping don't panic, so we do nothing here.
+  }
+
+  tick += applyLatency(CPU::FTL__PAGE_MAPPING, CPU::READ_INTERNAL);
+}
+
+void FastMapping::writeInternal(Request &req, uint64_t &tick, bool sendToPAL) {
+  PAL::Request palRequest(req);
+  uint64_t finishedAt = tick;
+
+  if (req.reqID >= 1025) {
+    int kkk = tick;
+    (void) kkk;
+  }
+
+  auto logicalBlockNumber = convertPageToBlock(req.lpn);
+  auto &block_opt = logicalToPhysicalBlockMapping[logicalBlockNumber];
+
+  if (block_opt.has_value() == false) {
+    // create new logical-physical block mapping
+    uint32_t pbn = getFreeBlock();
+    block_opt = pbn;
+    physicalToLogicalBlockMapping[pbn] = logicalBlockNumber;
+  }
+
+  uint32_t physicalBlockNumber;
+  uint32_t pageIndex;
+  Block *pBlock;
+  BlockType blockType;
+
+  if (!this->findValidPage(req.lpn, physicalBlockNumber, pageIndex, pBlock, blockType)) {
+    // no valid page. just write into data block.
+    physicalBlockNumber = block_opt.value();
+    pageIndex = this->convertPageToOffsetInBlock(req.lpn);
+    pBlock = &physicalBlocks[physicalBlockNumber];
+    blockType = kBlockTypeData;
+
+    pBlock->write(pageIndex, req.lpn, 0, tick); // tick stays
+
+    if (sendToPAL) {
+      palRequest.blockIndex = physicalBlockNumber;
+      palRequest.pageIndex = pageIndex;
+      palRequest.ioFlag = req.ioFlag;
+
+      pPAL->write(palRequest, finishedAt); // finishedAt += ...
+    }
+  } else {
+    // there is a valid page. we should invalidate the old page, 
+    // and create a new one in log block. this process may involve merging and erasing.
+
+    // no matter where the valid page is, we should invalidate it first
+
+    if (pBlock->getBlockIndex() == 9120 && pageIndex == 0) {
+      int kkk = pageIndex;
+      (void) kkk;
+    }
+
+    pBlock->invalidate(pageIndex, tick); // tick stays
+    if (blockType == kBlockTypeRW) {
+      // remove the original RW mapping
+      this->RWlogMapping.erase(req.lpn);
+    }
+
+    // follow the pseudo code in the paper
+    uint32_t pageOffset = this->convertPageToOffsetInBlock(req.lpn);
+
+    if (pageOffset == 0) {
+      // It's a beginning of one page. 
+      assert(SWBlock.has_value());
+      Block *swblock = &physicalBlocks[SWBlock.value()];
+
+      // Check if sw block is a clean block.
+      if (!swblock->isCleanBlock()) {
+        // If it is not, we should create a new SW log block
+        // recycle the old SW block first.
+
+        // merging is parrellel with writing the new SW block.
+        auto startTick = tick;
+        mergeLogBlock(SWBlock.value(), kBlockTypeSW, std::nullopt, startTick, palRequest, sendToPAL); // startTick += ...
+        finishedAt = std::max(finishedAt, startTick);
+
+        SWBlock = getFreeBlock();
+        // phy to logical mapping changed below.
+
+        swblock = &physicalBlocks[SWBlock.value()];
+      }
+
+      // write to the first page of SW block
+      swblock->write(0, req.lpn, 0, tick); // tick stays
+
+      // the first page should claim the ownership of the SW block.
+      physicalToLogicalBlockMapping[SWBlock.value()] = logicalBlockNumber;
+
+
+      if (sendToPAL) {
+        palRequest.blockIndex = SWBlock.value();
+        palRequest.pageIndex = 0;
+        palRequest.ioFlag = req.ioFlag;
+
+        auto startTick = tick;
+        pPAL->write(palRequest, startTick); // startTick += ...
+        finishedAt = std::max(finishedAt, startTick);
+      }
+    } else {
+      auto SWBlockOwner_opt = physicalToLogicalBlockMapping[SWBlock.value()];
+
+      if (SWBlockOwner_opt.has_value() && SWBlockOwner_opt.value() == logicalBlockNumber) {
+        // write into SW log block, or start merging...
+        Block &swblock = physicalBlocks[SWBlock.value()];
+        // We hope to see appending, but we still allow out-of-order page writing.
+
+        uint64_t lpn;
+        bool valid, erased;
+
+        swblock.getPageInfo(pageOffset, lpn, valid, erased);
+
+        if (erased) {
+          // clean page, just write into it.
+          swblock.write(pageOffset, req.lpn, 0, tick); // tick stays
+
+          if (sendToPAL) {
+            palRequest.blockIndex = SWBlock.value();
+            palRequest.pageIndex = pageOffset;
+            palRequest.ioFlag = req.ioFlag;
+
+            auto startTick = tick;
+            pPAL->write(palRequest, startTick); // tick += ...
+            finishedAt = std::max(finishedAt, startTick);
+          }
+        } else {
+          // merge: 
+          // the current SW log block, 
+          // the original data block, 
+          // and the writing page.
+          auto startTick = tick;
+          mergeLogBlock(SWBlock.value(), kBlockTypeSW, pageOffset, startTick, palRequest, sendToPAL); // startTick += ...
+          finishedAt = std::max(finishedAt, startTick);
+        }
+      } else {
+        // two case: 
+        // 1. SW Block has no owner
+        // 2. SW Block has another owner
+        // for both cases, we write into RW log block instead. 
+
+        // find a free RW log block
+        uint32_t freeRwBlockNumber = std::numeric_limits<uint32_t>::max();
+
+        for (uint32_t rwBlockNum : RWBlocks) {
+          Block &rwblock = physicalBlocks[rwBlockNum];
+          if (rwblock.getErasedPageCount() != 0) {
+            freeRwBlockNumber = rwBlockNum;
+            break;
+          }
+        }
+
+        if (freeRwBlockNumber == std::numeric_limits<uint32_t>::max()) {
+          // no free RW log block, we should recycle one.
+
+          uint32_t victimRwBlock = RWBlocks.front(); 
+          RWBlocks.pop_front();
+
+          // merge is parrellel with writing the new RW block.
+          auto startTick = tick;
+          mergeLogBlock(victimRwBlock, kBlockTypeRW, std::nullopt, startTick, palRequest, sendToPAL); // startTick += ...
+          finishedAt = std::max(finishedAt, startTick); 
+
+          freeRwBlockNumber = getFreeBlock();
+          RWBlocks.push_back(freeRwBlockNumber);
+
+          physicalToLogicalBlockMapping[freeRwBlockNumber] = std::nullopt;
+        }
+
+        // write into rwblock
+        Block &rwblock = physicalBlocks[freeRwBlockNumber];
+        auto nextFreePage = rwblock.getNextWritePageIndex(0);
+
+        rwblock.write(nextFreePage, req.lpn, 0, tick); // tick stays
+        RWlogMapping[req.lpn] = std::make_pair(freeRwBlockNumber, nextFreePage);
+
+        if (sendToPAL) {
+          palRequest.blockIndex = freeRwBlockNumber;
+          palRequest.pageIndex = nextFreePage;
+          palRequest.ioFlag = req.ioFlag;
+
+          auto startTick = tick;
+          pPAL->write(palRequest, startTick); // startTick += ...
+          finishedAt = std::max(finishedAt, startTick);
+        }
+      }
+    }
+  }
+
+
+  tick = finishedAt + applyLatency(CPU::FTL__PAGE_MAPPING, CPU::WRITE_INTERNAL);
+}
+
+
+
+void FastMapping::mergeLogBlock(uint32_t logBlockPhyNum,
+    enum BlockType blockType, std::optional<uint32_t> additionalPage, uint64_t &tick, PAL::Request &req, bool sendToPAL) {
+
+  std::vector<PAL::Request> readRequests;
+  std::vector<std::pair<PAL::Request, uint64_t>> writeRequests; // pair: request, lpn
+  std::vector<PAL::Request> eraseRequests;
+
+  Block &logBlock = physicalBlocks[logBlockPhyNum];
+  if (blockType == kBlockTypeRW) {
+    assert(additionalPage.has_value() == false);
+    
+    std::vector<uint32_t> logicalBlocks;
+    std::unordered_map<uint32_t, uint32_t> lbnToNewPbn, lbnToOldPbn;
+
+    for (uint32_t i = 0; i < param.pagesInBlock; i++) {
+      uint64_t lpn;
+      bool valid, erased;
+      logBlock.getPageInfo(i, lpn, valid, erased);
+
+      if (valid) {
+        logicalBlocks.emplace_back(convertPageToBlock(lpn));
+
+        // remove RW log mapping
+        RWlogMapping.erase(lpn);
+      }
+    }
+
+    // sort and remove duplicates
+    std::sort(logicalBlocks.begin(), logicalBlocks.end());
+    logicalBlocks.erase(std::unique(logicalBlocks.begin(), logicalBlocks.end()), logicalBlocks.end());
+
+    // assign new physical block number to each logical block
+    for (auto lbn : logicalBlocks) {
+      uint32_t newBlockPhyBlockNum = getFreeBlock();
+      lbnToNewPbn[lbn] = newBlockPhyBlockNum;
+      lbnToOldPbn[lbn] = logicalToPhysicalBlockMapping[lbn].value();
+
+      physicalToLogicalBlockMapping[newBlockPhyBlockNum] = lbn;
+      logicalToPhysicalBlockMapping[lbn] = newBlockPhyBlockNum;
+    }
+
+    for (auto lbn : logicalBlocks) {
+      // old data blocks:
+      uint32_t pbn = lbnToOldPbn[lbn];
+      Block &block = physicalBlocks[pbn];
+
+      // read from old data block, write to the new one
+      for (uint32_t i = 0; i < param.pagesInBlock; i++) {
+        if (block.isValid(i)) {
+          PAL::Request readReq(req);
+          readReq.blockIndex = pbn;
+          readReq.pageIndex = i;
+          readReq.ioFlag.set();
+          readRequests.emplace_back(readReq);
+
+          PAL::Request writeReq(req);
+          writeReq.blockIndex = lbnToNewPbn[lbn];
+          writeReq.pageIndex = i;
+          writeReq.ioFlag.set();
+          writeRequests.emplace_back(std::make_pair(writeReq, lbn * param.pagesInBlock + i));
+        }
+      }
+
+      // erase old data block
+      PAL::Request eraseReq(req);
+      eraseReq.blockIndex = pbn;
+      eraseReq.ioFlag.set();
+      eraseRequests.emplace_back(eraseReq);
+    }
+
+    // read from victim RW log block, write to the new one
+    for (uint32_t i = 0; i < param.pagesInBlock; i++) {
+      if (logBlock.isValid(i)) {
+        PAL::Request readReq(req);
+        readReq.blockIndex = logBlockPhyNum;
+        readReq.pageIndex = i;
+        readReq.ioFlag.set();
+        readRequests.emplace_back(readReq);
+
+        PAL::Request writeReq(req);
+        writeReq.blockIndex = lbnToNewPbn[convertPageToBlock(logBlock.getLPN(i))];
+        writeReq.pageIndex = convertPageToOffsetInBlock(logBlock.getLPN(i));
+        writeReq.ioFlag.set();
+        writeRequests.emplace_back(std::make_pair(writeReq, logBlock.getLPN(i)));
+      }
+    }
+
+    // erase old RW block
+    PAL::Request eraseReq(1);
+    eraseReq.blockIndex = logBlockPhyNum;
+    eraseReq.ioFlag.set();
+    eraseRequests.emplace_back(eraseReq);
+
+    // handle new RW block
+    uint32_t newBlockPhyBlockNum = getFreeBlock();
+    physicalToLogicalBlockMapping[newBlockPhyBlockNum] = std::nullopt;
+
+  } else if (blockType == kBlockTypeSW) {
+    // TODO: additional page is not implemented yet.
+
+    // check if we can use switching optimization.
+    auto SWOwner = physicalToLogicalBlockMapping[logBlockPhyNum].value();
+    uint32_t oldDataBlockPbn = logicalToPhysicalBlockMapping[SWOwner].value();
+
+    if (logBlock.getValidPageCount() == param.pagesInBlock) {
+      // switching
+      // old data block can be erased now.
+      // eraseInternal(oldDataBlockPbn, tick);
+
+      PAL::Request eraseReq = PAL::Request(req);
+      eraseReq.blockIndex = oldDataBlockPbn;
+      eraseReq.ioFlag.set();
+      eraseRequests.emplace_back(eraseReq);
+
+      // update logicalToPhysicalBlockMapping
+      logicalToPhysicalBlockMapping[SWOwner] = logBlockPhyNum;
+
+     } else {
+      // non-switching
+      // create a new data block, and copy all valid pages into it.
+      // create a new SW block.
+      // recyle the old data block and SW block.
+
+      uint32_t newDataBlockPhyNum = getFreeBlock();
+      Block &oldDataBlock = physicalBlocks[oldDataBlockPbn];
+      physicalToLogicalBlockMapping[newDataBlockPhyNum] = SWOwner;
+      logicalToPhysicalBlockMapping[SWOwner] = newDataBlockPhyNum;
+
+      // generate all page read, write and block erase requests.
+      for (uint32_t i = 0; i < param.pagesInBlock; i++) {
+        uint64_t lpn;
+        bool valid, erased;
+        logBlock.getPageInfo(i, lpn, valid, erased);
+
+        bool valid2;
+        oldDataBlock.getPageInfo(i, lpn, valid2, erased);
+
+        if (valid || valid2) {
+          // in log block or in data block, a copy is needed.
+          PAL::Request readReq(req);
+          if (valid) {
+            // read from log block
+            readReq.blockIndex = logBlockPhyNum;
+          } else {
+            // read from data block
+            readReq.blockIndex = oldDataBlockPbn;
+          }
+          readReq.pageIndex = i;
+          readReq.ioFlag.set();
+          readRequests.emplace_back(readReq);
+
+          PAL::Request writeReq(req);
+          writeReq.blockIndex = newDataBlockPhyNum;
+          writeReq.pageIndex = i;
+          writeReq.ioFlag.set();
+
+          writeRequests.emplace_back(
+              std::make_pair(writeReq, SWOwner *  param.pagesInBlock + i)); 
+        }
+      }
+
+      // erase two old blocks.
+      PAL::Request eraseReq = PAL::Request(req);
+      eraseReq.ioFlag.set();
+      eraseReq.blockIndex = oldDataBlockPbn;
+      eraseRequests.emplace_back(eraseReq);
+
+      eraseReq.blockIndex = logBlockPhyNum;
+      eraseRequests.emplace_back(eraseReq);
+
+      // get a new SW block.
+      SWBlock = getFreeBlock();
+      physicalToLogicalBlockMapping[SWBlock.value()] = std::nullopt;
+    }
+  } else 
+    assert(0);
+
+  // calc tick.
+  // read first, and then write and erase can be parrellel.
+  // use PAL to calc time, and update FTL meta data.
+
+  uint64_t readFinishAt = tick;
+  for (auto &req : readRequests) {
+    uint64_t readStartAt = tick;
+
+    physicalBlocks[req.blockIndex].read(req.pageIndex, 0, readStartAt);
+    if (sendToPAL) {
+      pPAL->read(req, readStartAt);
+      readFinishAt = std::max(readFinishAt, readStartAt);
+    }
+
+  }
+
+  uint64_t writeFinishAt = readFinishAt;
+  for (auto &pair : writeRequests) {
+    auto &req = pair.first;
+    auto lpn = pair.second;
+
+    uint64_t writeStartAt = readFinishAt;
+    physicalBlocks[req.blockIndex].write(req.pageIndex, lpn, 0, writeStartAt);
+
+    if (sendToPAL) {
+      pPAL->write(req, writeStartAt);
+      writeFinishAt = std::max(writeFinishAt, writeStartAt);
+    }
+  }
+
+  uint64_t eraseFinishAt = readFinishAt;
+  for (auto &req : eraseRequests) {
+    auto eraseStartAt = readFinishAt;
+    eraseInternal(req.blockIndex, eraseStartAt, sendToPAL);
+    eraseFinishAt = std::max(eraseFinishAt, eraseStartAt);
+  }
+
+  tick = std::max(writeFinishAt, eraseFinishAt);
+}
+
+bool FastMapping::findValidPage(uint32_t lpn, uint32_t &pbn, uint32_t &pageIdx,
+                                Block *&pBlock, enum BlockType &blockType) {
+
+  // fill impossible value to all output parameters
+  pbn = std::numeric_limits<uint32_t>::max();
+  pageIdx = std::numeric_limits<uint32_t>::max();
+  pBlock = nullptr;
+  blockType = kBlockTypeUnknown;
+
+  auto logicalBlockNumber = convertPageToBlock(lpn);
+  auto mapping = logicalToPhysicalBlockMapping[logicalBlockNumber];
+
+  if (mapping.has_value() == false) {
+    return false;
+  }
+
+  auto physicalBlockNumber = mapping.value();
+
+
+  // check if the page is valid
+  Block &block = physicalBlocks[physicalBlockNumber];
+
+  uint64_t logicalPageNumber;
+  bool valid, erased;
+
+  block.getPageInfo(this->convertPageToOffsetInBlock(lpn), logicalPageNumber, valid, erased);
+
+  if (valid) {
+    // locate it in the data block.
+    pbn = physicalBlockNumber;
+    pageIdx = this->convertPageToOffsetInBlock(lpn);
+    pBlock = &block;
+    blockType = kBlockTypeData;
+    return true;
+
+  } else {
+    // find in log blocks.
+
+    // in SW block?
+    if (SWBlock.has_value()) {
+      Block &swblock = physicalBlocks[SWBlock.value()];
+      uint32_t i = this->convertPageToOffsetInBlock(lpn);
+      swblock.getPageInfo(i, logicalPageNumber, valid, erased);
+      if (valid && logicalPageNumber == lpn) {
+        // found
+        pbn = SWBlock.value();
+        pageIdx = i;
+        pBlock = &swblock;
+        blockType = kBlockTypeSW;
+        return true;
+      }
+    }
+
+    // in RW block?
+    auto it = RWlogMapping.find(lpn);
+    if (it != RWlogMapping.end()) {
+      auto &pair = it->second;
+      Block &rwblock = physicalBlocks[pair.first];
+      uint32_t i = pair.second;
+      rwblock.getPageInfo(i, logicalPageNumber, valid, erased);
+      assert(valid && logicalPageNumber == lpn);
+      pbn = pair.first;
+      pageIdx = i;
+      pBlock = &rwblock;
+      blockType = kBlockTypeRW;
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  assert(0);
+}
+
+
+float FastMapping::calculateWearLeveling() {
+  // assert(0); // not implemented yet.
+  return 0.0f;
+}
+
+void FastMapping::calculateTotalPages(uint64_t &valid, uint64_t &invalid) {
+  valid = 0;
+  invalid = 0;
+
+  for (auto &block : physicalBlocks) {
+    valid += block.getValidPageCount();
+    invalid += block.getDirtyPageCount();
+  }
+}
+
+void FastMapping::getStatList(std::vector<Stats> &list, std::string prefix) {
+  (void) list, (void) prefix;
+  // assert(0); // not implemented yet.
+}
+
+void FastMapping::getStatValues(std::vector<double> &values) {
+  (void) values;
+  // assert(0); // not implemented yet.
+}
+
+void FastMapping::resetStatValues() {
+  // assert(0); // not implemented yet.
+}
+
+}  // namespace FTL
+
+}  // namespace SimpleSSD
diff --git a/ftl/fast_mapping.hh b/ftl/fast_mapping.hh
new file mode 100644
index 0000000..5ce4587
--- /dev/null
+++ b/ftl/fast_mapping.hh
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2017 CAMELab
+ *
+ * This file is part of SimpleSSD.
+ *
+ * SimpleSSD is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * SimpleSSD is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with SimpleSSD.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __FTL_FAST_MAPPING__
+#define __FTL_FAST_MAPPING__
+
+#include <cinttypes>
+#include <unordered_map>
+#include <vector>
+#include <deque>
+#include <optional>
+
+#include "ftl/abstract_ftl.hh"
+#include "ftl/common/block.hh"
+#include "ftl/ftl.hh"
+#include "pal/pal.hh"
+
+namespace SimpleSSD {
+
+namespace FTL {
+
+/* 
+
+# Data Structure:
+- `blockMappingTable`: map logical block number -> physical block number
+- `blocks`: physical block number -> block info.
+- `SWBlock`: The SW log block.
+- `RWBlocks`: All RW log blocks.
+
+# Invariance:
+- For every logical page number, there should be at most one valid physical page
+  - This page should be found at 
+    1. the coresponding location by the block in blockMappingTable
+    2. The SW log block or RW log blocks.
+- We don't promise a sequencial writing order, even in SW log blocks.
+
+# Algorithm design:
+
+## read:
+1. check block mapping table, suppose block pbn X.
+  - no mapped: no-data panic
+
+2. check the corresponding page status:
+  - if valid, just return
+  - if erased && invalid: no-data panic
+  - if invalid: check log blocks.
+  
+3. If not found: otherwise: no-data panic
+
+
+## write (a page):
+Follow the psuedo code in the paper.
+
+1. Check if this page can insert to block_mapping_table[lbn] directly.
+
+2. Otherwise, there are two situations:
+  1. offset = 0 (the beginning of a block)
+    Merge and recycle the current SW log block.
+    Create a new one that begins with the page inserted.
+
+  2. offset != 0
+    1. if the current logical owner of SW log block contains the page inserted. 
+      Try to insert to the corresponding location of the SW log block.
+      If conflict, merge the current SW log block, the original data block
+       (and the page inserted).
+    2. if not
+      Try to write to RW log block. 
+      If no free page, then recyle one of RW log block (in round robin style), 
+      and create a new one.      
+
+*/
+
+class FastMapping : public AbstractFTL {
+ private:
+  PAL::PAL *pPAL;
+
+  ConfigReader &conf;
+
+  // logical block number -> physical block number
+  std::vector<std::optional<uint32_t>>
+      logicalToPhysicalBlockMapping; 
+  
+  std::vector<std::optional<uint32_t>>
+      physicalToLogicalBlockMapping;
+
+  // physical block number -> block info
+  std::vector<Block> physicalBlocks; // in use
+  std::deque<uint32_t> freeBlocks;
+
+  std::unordered_map<uint64_t, std::pair<uint32_t, uint32_t>>
+    RWlogMapping; // logical page number -> (physical block number, page index)
+
+
+  const uint32_t kRWBlockCnt = 6;
+  std::optional<uint32_t> SWBlock;
+  std::deque<uint32_t> RWBlocks;
+
+  struct {
+    uint64_t reclaimedBlocks;
+    uint64_t validSuperPageCopies;
+    uint64_t validPageCopies;
+  } stat;
+
+  float freeBlockRatio();
+  uint32_t getFreeBlock();
+
+  float calculateWearLeveling();
+  void calculateTotalPages(uint64_t &, uint64_t &);
+
+  void readInternal(Request &, uint64_t &);
+  void writeInternal(Request &, uint64_t &, bool = true);
+
+  enum BlockType{
+    kBlockTypeData,
+    kBlockTypeSW,
+    kBlockTypeRW,
+    kBlockTypeUnknown
+  };
+
+  // sometimes we merge the current writing page with previous data.
+  void mergeLogBlock(uint32_t physicalBlockNumber, enum BlockType blockType, 
+    std::optional<uint32_t> additionalPage, uint64_t &tick, PAL::Request &req, bool sendToPAL);
+
+  // find the only one valid page
+  // if found return true, otherwise return false
+  bool findValidPage(uint32_t lpn, uint32_t &pbn, uint32_t &pageIdx, 
+    Block *&pBlock, enum BlockType &blockType);
+
+  void eraseInternal(uint32_t physicalBlockNum, uint64_t &tick, bool sendToPAL);
+
+ public:
+  FastMapping(ConfigReader &, Parameter &, PAL::PAL *, DRAM::AbstractDRAM *);
+  ~FastMapping();
+
+  bool initialize() override;
+
+  uint32_t convertPageToBlock(uint64_t);
+  uint64_t convertPageToOffsetInBlock(uint64_t);
+
+  void read(Request &, uint64_t &) override;
+  void write(Request &, uint64_t &) override;
+  void trim(Request &, uint64_t &) override;
+
+  void format(LPNRange &, uint64_t &) override;
+
+  Status *getStatus(uint64_t, uint64_t) override;
+
+  void getStatList(std::vector<Stats> &, std::string) override;
+  void getStatValues(std::vector<double> &) override;
+  void resetStatValues() override;
+};
+
+}  // namespace FTL
+
+}  // namespace SimpleSSD
+
+#endif
diff --git a/ftl/ftl.cc b/ftl/ftl.cc
index 083631e..6fd435d 100644
--- a/ftl/ftl.cc
+++ b/ftl/ftl.cc
@@ -20,6 +20,7 @@
 #include "ftl/ftl.hh"
 
 #include "ftl/page_mapping.hh"
+#include "ftl/fast_mapping.hh"
 
 namespace SimpleSSD {
 
@@ -44,6 +45,9 @@ FTL::FTL(ConfigReader &c, DRAM::AbstractDRAM *d) : conf(c), pDRAM(d) {
     case PAGE_MAPPING:
       pFTL = new PageMapping(conf, param, pPAL, pDRAM);
       break;
+    case FAST_MAPPING:
+      pFTL = new FastMapping(conf, param, pPAL, pDRAM);
+      break;
   }
 
   if (param.totalPhysicalBlocks <=
diff --git a/hil/nvme/controller.cc b/hil/nvme/controller.cc
index 36db125..e15b63b 100644
--- a/hil/nvme/controller.cc
+++ b/hil/nvme/controller.cc
@@ -21,6 +21,7 @@
 
 #include <algorithm>
 #include <cmath>
+#include <limits>
 
 #include "hil/nvme/interface.hh"
 #include "hil/nvme/ocssd.hh"
diff --git a/sim/trace.hh b/sim/trace.hh
index 2bdd0c4..cd8cde3 100644
--- a/sim/trace.hh
+++ b/sim/trace.hh
@@ -37,6 +37,7 @@ typedef enum {
   LOG_ICL_GENERIC_CACHE,
   LOG_FTL,
   LOG_FTL_PAGE_MAPPING,
+  LOG_FTL_FAST_MAPPING,
   LOG_PAL,
   LOG_PAL_OLD,
   LOG_NUM
-- 
2.34.1

